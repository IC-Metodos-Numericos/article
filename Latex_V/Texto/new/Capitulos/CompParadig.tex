\chapter{Comparação entre Paradigmas de Programação}
Os métodos numéricos podem ser implementados utizando diferentes paradigmas de programação, como o imperativo e o funcional. No paradigma imperativo, o foco está na sequência de comandos que modificam o estado do programa, enquanto no paradigma funcional, a ênfase está na aplicação de funções e na imutabilidade dos dados. Ao implementar métodos numéricos, o paradigma imperativo pode ser mais intuitivo para aqueles familiarizados com a manipulação direta de variáveis e estruturas de controle, como loops e condicionais. Por outro lado, o paradigma funcional pode oferecer vantagens em termos de clareza e concisão, especialmente ao lidar com operações matemáticas complexas e recursivas. No entanto, a escolha do paradigma pode influenciar o desempenho e a legibilidade do código, dependendo do contexto e dos requisitos específicos do problema numérico em questão. Portanto, é importante considerar as características de cada paradigma ao implementar métodos numéricos para garantir eficiência e manutenção do código.

Neste capítulo, apresentamos o pseudocódigo dos métodos abordados anteriormente, em ambos os paradigmas de programação: imperativo e funcional. A seguir, discutimos as diferenças e semelhanças entre as implementações, destacando as vantagens e desvantagens de cada abordagem. A implementação real em C, Python e Haskell pode ser encontrada no repositório Github do projeto.

\section{Comparação Entre Paradigmas}

A comparação entre os paradigmas de programação imperativo e funcional na implementação de métodos numéricos revela diferenças significativas em termos de estrutura, legibilidade e manutenção do código. No paradigma imperativo, o foco está na sequência de comandos que modificam o estado do programa, o que pode tornar o código mais intuitivo para aqueles familiarizados com a manipulação direta de variáveis e estruturas de controle, como loops e condicionais. Por exemplo, no método do ponto fixo iterativo, a utilização de um loop explícito facilita a compreensão do fluxo de iterações. Por outro lado, o paradigma funcional enfatiza a aplicação de funções e a imutabilidade dos dados, o que pode resultar em um código mais conciso e expressivo. No método do ponto fixo recursivo, a ausência de estados mutáveis e a utilização de funções auxiliares tornam o código mais fácil de entender em termos matemáticos. No entanto, a recursão pode levar a problemas de desempenho e consumo de memória em casos de iterações profundas. Em termos de manutenção, o código funcional pode ser mais fácil de modificar, pois as funções são independentes e não dependem de estados compartilhados. Em resumo, a escolha entre os paradigmas deve considerar o contexto do problema, a familiaridade do programador com cada abordagem e os requisitos específicos de desempenho e legibilidade do código.

A seguir discutiremos uma análise quantitativa realizada através de métricas como contagem de linhas de código, nível de otimização do compilador, uso de memória, processamento e tempo de execução para avaliar o desempenho das implementações em diferentes cenários.
Para garantir a melhor comparação possível, todas as implementações foram otimizadas ao máximo, utilizando as melhores práticas de cada linguagem e paradigma. As medições foram realizadas em um ambiente controlado, utilizando a mesma máquina e condições de teste para minimizar variações externas. Além disso, foram considerados diferentes casos de teste, incluindo funções simples e complexas, para avaliar a robustez e eficiência das implementações em situações variadas.

O uso de linguagens como C para o paradigma imperativo e Haskell para o funcional permitiu explorar as características intrínsecas de cada abordagem. A análise dos resultados revelou que, embora o código imperativo em C tenha apresentado melhor desempenho em termos de tempo de execução e uso de memória para funções simples, o código funcional em Haskell mostrou-se mais eficiente em termos de legibilidade e manutenção, especialmente para funções matemáticas complexas. Além disso, a capacidade do Haskell de lidar com recursão e funções de ordem superior facilitou a implementação de algoritmos numéricos mais sofisticados. Em conclusão, a escolha do paradigma deve levar em consideração não apenas o desempenho bruto, mas também a clareza do código e a facilidade de manutenção a longo prazo.

Teste realizados no metódo do ponto fixo foram coletados e analisados, gerando os gráficos a seguir:
\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/cpu/boxplot_cpu_mpf.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/cpu/violinplot_cpu_mpf.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/cpu/mean_cpu_mpf.png}
    \caption{ Comparação do Uso de CPU entre Implementações Iterativa e Recursiva.}
    \label{fig: cpu_use_mpf}
\end{figure}

Os gráficos mostram uma melhor performance em relação ao uso de CPU de execução do C, seguido pelo Haskell e Python.

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/mem/mean_memfis_mpf.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/mem/mean_mempriv_mpf.png}
    \caption{ Comparação do Uso de Memória entre Implementações Iterativa e Recursiva.}
    \label{fig: memory_use_mpf}
\end{figure}

O grafico de Memória Privada mostra o total de memória alocada para o processo, enquanto o gráfico de Memória Física mostra a quantidade de memória realmente utilizada durante a execução.
Em relação ao uso de memória, o C também apresentou a melhor performance, seguido pelo Python e Haskell.

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/time/mean_time_bar_nr.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/time/time_hist_nr.png}
    \caption{ Comparação do Tempo de Execução entre Implementações Iterativa e Recursiva.}
    \label{fig: time_use_mpf}
\end{figure}

Em relação ao tempo de execução, o C novamente apresentou a melhor performance que foi muito parecida com a do Haskell. O Python por sua vez apresentou um desempenho muito pior em relação as outras linguagens.

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/time/trend/trend_langs_nr.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/time/trend/trend_c_nr.png}
    \caption{ Análise de Tendência do Tempo de Execução entre Implementações Iterativa e Recursiva. Parte 1}
    \label{fig: trend_time_use_mpf1}

\end{figure}
\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/time/trend/trend_hs_nr.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/time/trend/trend_py_nr.png}
    \caption{ Análise de Tendência do Tempo de Execução entre Implementações Iterativa e Recursiva. Parte 2}
    \label{fig: trend_time_use_mpf2}

\end{figure}

O gráfico de Trend mostra a tendencia do uso do tempo de execução em relação à memoria física utilizada. Podemos observar que o Python apresenta uma tendência mais estável. O Haskell apresenta uma tendência mais acentuada, enquanto o C apresenta uma tendência intermediária entre as duas.

Testes realizados no metódo de Newton-Raphson unidimensional foram coletados e analisados tanto iterativamente e recursivamente, vale ressaltar que a linguagem Haskell foi implementada apenas na forma recursiva, gerando os gráficos a seguir:

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/nr/cpu/cpu_nr_hist_iter_vs_recursive_nr.png}
    \caption{ Comparação do Uso de CPU entre Implementações Iterativa e Recursiva.}
    \label{fig: cpu_use_hist_nr}
\end{figure}

Comparando o uso de CPU entre as implementações iterativa e recursiva, podemos observar que a implementação iterativa em C apresenta um desempenho muito superior em relação à implementação iterativa em Python. A implementação recursiva em Haskell, por sua vez, mostra um desempenho intermediário, ficando atrás do C, mas à frente do Python quando implementados recusivamente.
Comparando C e Python iterativamente e recursivamente, ambas tem o desempenho melhor na forma recursiva, gastando menos CPU, porém o C ainda é muito mais eficiente que o Python.


\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/nr/mem/fismem_nr_hist_iter_vs_recursive.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/nr/mem/privmem_nr_hist_iter_vs_recursive.png}
    \caption{ Comparação do Uso de Memória entre Implementações Iterativa e Recursiva.}
    \label{fig: memory_use_hist_nr}
\end{figure}

A analise da memória privada mostra que a implementação iterativa em C e python não mostraram muitas diferenças quando comparadas com suas contrapartes recursivas. Já a implementação recursiva em Haskell apresentou um uso de memória privada significativamente maior, o que pode ser atribuído à natureza da recursão e à forma como o Haskell gerencia a memória para chamadas de função recursivas.

Já a memória física utilizada mostrou que a implementação iterativa em C utilizou levemente menos memória física em comparação com a implementação recursiva. A implementação iterativa em Python, por outro lado, utilizou uma quantidade de memória física que não se alterou mas foi muito maior do que ambas outras linguagens nas duas implementações, tanto iterativa quanto recursiva.

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/nr/time/time_nr_hist_iter_vs_recursive.png}
    \caption{ Comparação do Tempo de Execução entre Implementações Iterativa e Recursiva.}
    \label{fig: time_use_hist_nr}
\end{figure}

O tempo de execução mostra que a implementação iterativa em C foi a mais rápida, seguida pela implementação recursiva em C que por sua vez é seguida da implementação em Haskell. A implementação iterativa em Python foi a mais lenta entre as três, mas ainda assim apresentou um desempenho muito melhor quando é implementada recursivamente.


\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/nr/time/time_nr_violin_iter_vs_recursive.png}
    \caption{ Violin Plot do Tempo de Execução entre Implementações Iterativa e Recursiva.}
    \label{fig: time_use_violin_nr}
\end{figure}

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/nr/stacked.png}
    \caption{ Gráfico Empilhado do Tempo de Execução entre Implementações Iterativa e Recursiva. }
    \label{fig: time_dist_per_lang_nr}
\end{figure}


Ambos os graficos de Violin Plot e Área Empilhada reforçam a análise anterior, mostrando claramente a superioridade do C em termos de tempo de execução, seguido pelo Haskell e Python. Apesar disso, na implementação recursiva, o Haskell mostrou-se ligeramente mais estável do que o C. O python por sua vez apresentou uma variação maior no tempo de execução em ambas implementações, mas a recursiva ainda melhor que a iterativa.


\begin{figure}[H]
    \centering
    \makebox[\textwidth][c]{%
        \includegraphics[width=1.15\textwidth]{Imagens/paradComp/nr/scatterMatrix_nr.png}%
    }
    \caption{Matriz de Dispersão das Métricas Coletadas.}
    \label{fig: scatterMatrix_nr}
\end{figure}

A matriz de dispersão das métricas coletadas oferece uma visão abrangente das relações entre diferentes variáveis, como uso de CPU, memória física, memória privada e tempo de execução. Observa-se que há correlações positivas entre o uso de CPU e o tempo de execução, indicando que implementações que consomem mais CPU tendem a levar mais tempo para completar.
