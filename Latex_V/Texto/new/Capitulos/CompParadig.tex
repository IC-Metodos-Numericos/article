\chapter{Comparação entre Paradigmas de Programação}
Os métodos numéricos podem ser implementados utizando diferentes paradigmas de programação, como o imperativo e o funcional. No paradigma imperativo, o foco está na sequência de comandos que modificam o estado do programa, enquanto no paradigma funcional, a ênfase está na aplicação de funções e na imutabilidade dos dados. Ao implementar métodos numéricos, o paradigma imperativo pode ser mais intuitivo para aqueles familiarizados com a manipulação direta de variáveis e estruturas de controle, como loops e condicionais. Por outro lado, o paradigma funcional pode oferecer vantagens em termos de clareza e concisão, especialmente ao lidar com operações matemáticas complexas e recursivas. No entanto, a escolha do paradigma pode influenciar o desempenho e a legibilidade do código, dependendo do contexto e dos requisitos específicos do problema numérico em questão. Portanto, é importante considerar as características de cada paradigma ao implementar métodos numéricos para garantir eficiência e manutenção do código.

Neste capítulo, apresentamos o pseudocódigo dos métodos abordados anteriormente, em ambos os paradigmas de programação: imperativo e funcional. A seguir, discutimos as diferenças e semelhanças entre as implementações, destacando as vantagens e desvantagens de cada abordagem. A implementação real em C, Python e Haskell pode ser encontrada no repositório Github do projeto.


\section{Pseudocódigo de Métodos Numéricos}
\subsection{Método do Ponto Fixo}
\subsubsection{Imperativa}

\begin{algorithm}[H]
    \caption{Método do Ponto Fixo Iterativo}
    \label{alg:pontofixo_imperativo}
    \begin{algorithmic}[1]
        \Procedure{Main}{}
            \State $x_0 \gets 1.5$ \Comment{Chute inicial}
            \State $\text{tol} \gets 10^{-6}$ \Comment{Tolerância}
            \State $N \gets 100$ \Comment{Número máximo de iterações}
            
            \State Inicializar vetor $H$ de tamanho $N+1$ \Comment{Alocação dinâmica}
            \State $x \gets x_0$
            \State $H[0] \gets x_0$
            
            \For{$i \gets 0$ \textbf{to} $N$}
                \State $x_{\text{next}} \gets \sin(x^2 + \cos(x))$ \Comment{Função $g(x)$}
                \State $H[i+1] \gets x_{\text{next}}$ \Comment{Salva no histórico}
                
                \If{$|x_{\text{next}} - x| < \text{tol}$}
                    \State \textbf{Imprimir} "Raiz: " $x_{\text{next}}$
                    \State \textbf{Imprimir} "Iterações: " $i+1$
                    \State \textbf{Imprimir} Histórico $H[0 \dots i+1]$
                    \State \Return 0 \Comment{Sucesso}
                \EndIf
                
                \State $x \gets x_{\text{next}}$ \Comment{Atualiza para próxima iteração}
            \EndFor
            
            \State \textbf{Imprimir} "Falha na convergência"
            \State Liberar memória de $H$
            \State \Return 1
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsubsection{Funcional}

\begin{algorithm}[H]
    \caption{Método do Ponto Fixo Recursivo}
    \label{alg:pontofixo_funcional}
    \begin{algorithmic}[1]
        \Function{g}{$x$}
            \State \Return $\sin(x^2 + \cos(x))$
        \EndFunction

        \Procedure{FixedPoint}{$x_0, \text{tol}, \text{maxIters}$}
            
            \Function{Go}{$x, \text{iter}, \text{acc}$} \Comment{Função auxiliar recursiva}
                \If{$\text{iter} \geq \text{maxIters}$}
                    \State \Return $(x, \text{iter}, \text{acc})$ \Comment{Limite atingido}
                \EndIf

                \State $x_{\text{next}} \gets g(x)$
                
                \If{$|x_{\text{next}} - x| < \text{tol}$}
                    \State \Return $(x_{\text{next}}, \text{iter} + 1, \text{acc} \cup [x_{\text{next}}])$ \Comment{Convergiu}
                \Else
                    \State \Return \Call{Go}{$x_{\text{next}}, \text{iter} + 1, \text{acc} \cup [x_{\text{next}}]$} \Comment{Recursão}
                \EndIf
            \EndFunction

            \State \Return \Call{Go}{$x_0, 0, [x_0]$} \Comment{Chamada inicial com lista [x0]}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{Método de Newton-Raphson Unidimensional}

\subsubsection{Imperativa}

\begin{algorithm}[H]
    \caption{Newton-Raphson Iterativo}
    \label{alg:newton_imperativo}
    \begin{algorithmic}[1]
        \Procedure{NewtonIter}{$f, f', x_0, \text{maxIter}$}
            \State $x \gets x_0$ \Comment{Inicialização da variável}
            \For{$i \gets 0$ \textbf{to} $\text{maxIter}$}
                \State $fx \gets f(x)$
                \State $dfx \gets f'(x)$
                \State $x_{\text{next}} \gets x - \frac{fx}{dfx}$
                \State $x \gets x_{\text{next}}$ \Comment{Atualiza o valor atual}
            \EndFor
            \State \Return $x$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsubsection{Funcional}

\begin{algorithm}[H]
    \caption{Newton-Raphson Recursivo}
    \label{alg:newton_funcional}
    \begin{algorithmic}[1]
        \Procedure{NewtonRecursive}{$f, f', x_0, \text{maxIter}$}
            
            \Function{Iterate}{$x, n$} \Comment{Função auxiliar (cláusula where)}
                \If{$n = 0$}
                    \State \Return $x$ \Comment{Caso base: fim das iterações}
                \Else
                    \State $x_{\text{next}} \gets x - \frac{f(x)}{f'(x)}$
                    \State \Return \Call{Iterate}{$x_{\text{next}}, n - 1$} \Comment{Passo recursivo}
                \EndIf
            \EndFunction

            \State \Return \Call{Iterate}{$x_0, \text{maxIter}$} \Comment{Chamada inicial}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\section{Comparação Entre Paradigmas}

A comparação entre os paradigmas de programação imperativo e funcional na implementação de métodos numéricos revela diferenças significativas em termos de estrutura, legibilidade e manutenção do código. No paradigma imperativo, o foco está na sequência de comandos que modificam o estado do programa, o que pode tornar o código mais intuitivo para aqueles familiarizados com a manipulação direta de variáveis e estruturas de controle, como loops e condicionais. Por exemplo, no método do ponto fixo iterativo, a utilização de um loop explícito facilita a compreensão do fluxo de iterações. Por outro lado, o paradigma funcional enfatiza a aplicação de funções e a imutabilidade dos dados, o que pode resultar em um código mais conciso e expressivo. No método do ponto fixo recursivo, a ausência de estados mutáveis e a utilização de funções auxiliares tornam o código mais fácil de entender em termos matemáticos. No entanto, a recursão pode levar a problemas de desempenho e consumo de memória em casos de iterações profundas. Em termos de manutenção, o código funcional pode ser mais fácil de modificar, pois as funções são independentes e não dependem de estados compartilhados. Em resumo, a escolha entre os paradigmas deve considerar o contexto do problema, a familiaridade do programador com cada abordagem e os requisitos específicos de desempenho e legibilidade do código.

A seguir discutiremos uma análise quantitativa realizada através de métricas como contagem de linhas de código, nível de otimização do compilador, uso de memória, processamento e tempo de execução para avaliar o desempenho das implementações em diferentes cenários.
Para garantir a melhor comparação possível, todas as implementações foram otimizadas ao máximo, utilizando as melhores práticas de cada linguagem e paradigma. As medições foram realizadas em um ambiente controlado, utilizando a mesma máquina e condições de teste para minimizar variações externas. Além disso, foram considerados diferentes casos de teste, incluindo funções simples e complexas, para avaliar a robustez e eficiência das implementações em situações variadas.

O uso de linguagens como C para o paradigma imperativo e Haskell para o funcional permitiu explorar as características intrínsecas de cada abordagem. A análise dos resultados revelou que, embora o código imperativo em C tenha apresentado melhor desempenho em termos de tempo de execução e uso de memória para funções simples, o código funcional em Haskell mostrou-se mais eficiente em termos de legibilidade e manutenção, especialmente para funções matemáticas complexas. Além disso, a capacidade do Haskell de lidar com recursão e funções de ordem superior facilitou a implementação de algoritmos numéricos mais sofisticados. Em conclusão, a escolha do paradigma deve levar em consideração não apenas o desempenho bruto, mas também a clareza do código e a facilidade de manutenção a longo prazo.

Teste realizados no metódo do ponto fixo foram coletados e analisados, gerando os gráficos a seguir:

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/cpu/boxplot_cpu_mpf.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/cpu/violinplot_cpu_mpf.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/cpu/mean_cpu_mpf.png}
    \caption{ Comparação do Uso de CPU entre Implementações Iterativa e Recursiva.}
    \label{fig: cpu_use_mpf}
\end{figure}

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/mem/mean_memfis_mpf.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/mem/mean_mempriv_mpf.png}
    \caption{ Comparação do Uso de Memória entre Implementações Iterativa e Recursiva.}
    \label{fig: memory_use_mpf}
\end{figure}

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/time/mean_time_bar_nr.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/time/time_hist_nr.png}
    \caption{ Comparação do Tempo de Execução entre Implementações Iterativa e Recursiva.}
    \label{fig: time_use_mpf}
\end{figure}

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/time/trend/trend_langs_nr.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/time/trend/trend_c_nr.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/time/trend/trend_hs_nr.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/mpf/time/trend/trend_py_nr.png}
    \caption{ Análise de Tendência do Tempo de Execução entre Implementações Iterativa e Recursiva.}
    \label{fig: trend_time_use_mpf}

\end{figure}

Testes realizados no metódo de Newton-Raphson unidimensional foram coletados e analisados, gerando os gráficos a seguir:

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/nr/cpu/cpu_nr_hist_iter_vs_recursive_nr.png}
    \caption{ Comparação do Uso de CPU entre Implementações Iterativa e Recursiva.}
    \label{fig: cpu_use_hist_nr}
\end{figure}

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/nr/mem/fismem_nr_hist_iter_vs_recursive.png}
    \includegraphics[width=1\textwidth]{Imagens/paradComp/nr/mem/privmem_nr_hist_iter_vs_recursive.png}
    \caption{ Comparação do Uso de Memória entre Implementações Iterativa e Recursiva.}
    \label{fig: memory_use_hist_nr}
\end{figure}

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/nr/time/time_nr_hist_iter_vs_recursive.png}
    \caption{ Comparação do Tempo de Execução entre Implementações Iterativa e Recursiva.}
    \label{fig: time_use_hist_nr}
\end{figure}

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/nr/time/time_nr_violin_iter_vs_recursive.png}
    \caption{ Violin Plot do Tempo de Execução entre Implementações Iterativa e Recursiva.}
    \label{fig: time_use_violin_nr}
\end{figure}

\begin{figure}[H]
    \centering
    \makebox[\textwidth][c]{%
        \includegraphics[width=1.15\textwidth]{Imagens/paradComp/nr/scatterMatrix_nr.png}%
    }
    \caption{Matriz de Dispersão das Métricas Coletadas.}
    \label{fig: scatterMatrix_nr}
\end{figure}

\begin{figure}[H]
    \centering 
    \includegraphics[width=1\textwidth]{Imagens/paradComp/nr/stacked.png}
    \caption{ Gráfico Empilhado do Tempo de Execução entre Implementações Iterativa e Recursiva. }
    \label{fig: time_dist_per_lang_nr}
\end{figure}